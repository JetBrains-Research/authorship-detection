\section*{Заключение}
Главным результатом данной работы стала модель, улучшающая точность определения авторства по коду на языках программирования C++, Java и Python по сравнению с имеющимися исследованиями в области. В отличие от предыдущих исследований, использовавших свойства конкретных языков и требовавших модификации решений для применения к другим языкам программирования, предложенное решение не нуждается в дополнительной модификации. Также в рамках данной работы были достигнуты следующие результаты:
\begin{itemize}
    \item Предложен метод для сбора примеров кода с известным автором из произвольных проектов, использовавших при разработке VCS git. Метод основывается на рассмотрении истории проекта и ее дальнейшем разбиении на изменения небольших фрагментов кода. С помощью предложенного подхода можно строить датасеты для тестирования решений в большем масштабе, чем это было возможно ранее, изучать поведение моделей при разбиении тренировочной и тестовой выборки во времени, изучать влияние контекста на точность определения автора кода.
    \item Предложенный подход к сбору данных был реализован и протестирован на Java-проекте с открытым исходным кодом IntelliJ IDEA. Из него было получено 2 миллиона изменений методов сделанных 500 разработчиками. Из полученных данных было сформировано 7 датасетов для тестирования моделей в разных условиях. Датасеты отличаются числом авторов, числом примеров, степенью несбалансированности. Также представлены датасеты, в которых тренировочная и тестовая выборки разбиты во времени и разделены по частям проекта. Подобные наборы данных до этого не существовали для промышленного кода.
    \item Созданы две модели для определения авторства по коду. Первая из них это нейросеть, использующая механизм внимания и эмбеддинги на основе путей и токенов в AST для векторизации одного или нескольких фрагментов кода. Предсказание автора делается по полученному вектору. Модель нацелена на использовании в случае большого количества данных, тысяч или десятков тысяч примеров от каждого из известных разработчиков. Такой масштаб достигается в крупных промышленных проектах. Вторая модель представляет собой случайный лес, обучаемый на частотах встречаемости путей и токенов в AST. Для уменьшения числа факторов и увеличения точности применяется филтрация на основе совместной информации значения фактора и автора. Модель применяется в случае небольшого количества данных, от десятка до нескольких сотен примеров от каждого автора. Обе модели не используют факторов, специфичных для конкретного языка и для применения требуют только построения AST.
    \item Улучшена точность определения авторства для датасетов на языках Python и Java, повторен результат для C++. При этом использовалась модель на основе случайного леса, поскольку датасеты в предыдущих исследованиях имели небольшой размер. Нейросетевая модель была протестирована на датасетах, собранных из проекта IntelliJ IDEA, представив базовый результат для будущих исследований.
\end{itemize}

Дальнейшая работа возможна в нескольких направлениях:
\begin{itemize}
    \item Применить предложенные модели к коду на других языках программирования. Помимо Java, C++ и Python в современных исследованиях было рассмотрено только определение авторства для Javascript \cite{Wisse2015}. Поскольку предложенные модели позволяют работать с произвольным языком, с их помощью можно расширить множество исследуемых языков.
    \item Собрать датасеты для определения авторства, моделирующие разные условия применения полученных решений. Например, поместить в тренировочную и тестовую выборки код одних и тех же разработчиков, но в разных проектах, собрать больше данных с выборками, разделенными по времени, сделать это для разных языков программирования.
    \item Научиться решать задачу профилирования разработчиков. Нейросетевая модель в процессе работы строит векторы для фрагментов кода. Эксперименты показывают, что по ним можно определять автора фрагмента. В задаче профилирования вместо этого требуется предсказать какие-то свойства автора. Ими могут выступать опыт работы, уровень экспертизы в отдельных областях, знание других языков. Решение задачи профилирования интересно для определения того, как вышеописанные свойства программиста влияют на код, который он пишет.
\end{itemize}
