# coding=utf-8
# Utility classes wrapping all entities generated by PathMiner.

from collections import namedtuple
from typing import List

import numpy as np


class PathContext:

    def __init__(self, start_token, path, end_token):
        self.start_token = start_token
        self.path = path
        self.end_token = end_token

    @classmethod
    def fromstring(cls, s, sep=' '):
        return cls(*map(int, s.split(sep)))

    def resolve(self, dataset):
        return dataset.get_token(self.start_token), dataset.get_path(self.path), dataset.get_token(self.end_token)


PathContexts = namedtuple(
    'PathContexts',
    ('starts', 'paths', 'ends')
)


def path_contexts_from_index(path_contexts: PathContexts, index: np.ndarray) -> PathContexts:
    return PathContexts(starts=path_contexts.starts[index],
                        paths=path_contexts.paths[index],
                        ends=path_contexts.ends[index])


def concat_path_contexts(path_contexts: List[PathContexts]) -> PathContexts:
    return PathContexts(starts=np.concatenate([pcs.starts for pcs in path_contexts]),
                        paths=np.concatenate([pcs.paths for pcs in path_contexts]),
                        ends=np.concatenate([pcs.ends for pcs in path_contexts]))


class Path:

    def __init__(self, node_types):
        self.node_types = node_types

    def substitute_nodes(self, nodes):
        return list(map(lambda ind: nodes[ind], self.node_types))

    def prettyprint(self, nodes):
        return ' '.join(map(lambda node: node.prettyprint(), self.substitute_nodes(nodes)))


class NodeType:

    def __init__(self, node_type, direction):
        self.node_type = node_type
        self.direction = direction

    def prettyprint(self):
        if self.direction == 'UP':
            arrow = u'↑'
        elif self.direction == 'DOWN':
            arrow = u'↓'
        else:
            arrow = ' ' + self.direction
        return self.node_type + arrow
