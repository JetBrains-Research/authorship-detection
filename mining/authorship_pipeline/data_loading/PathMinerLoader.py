from typing import Tuple, Union, List

import numpy as np
import pandas as pd

from data_loading.UtilityEntities import PathContext, Path, NodeType, PathContexts
from util import ProcessedFolder


# Loads all .csv files generated by AstMiner in np.ndarray
class PathMinerLoader:

    def __init__(self, project_folder: ProcessedFolder, change_entities: pd.Series):
        self._tokens = self._load_tokens(project_folder.tokens_file)
        self._node_types = self._load_node_types(project_folder.node_types_file)
        self._paths = self._load_paths(project_folder.path_ids_file)
        self._labels, self._path_contexts = self._load_path_contexts_files(project_folder.file_changes, change_entities)
        self._n_classes = np.unique(self._labels).size

    def _load_tokens(self, tokens_file: str) -> np.ndarray:
        return self._series_to_ndarray(
            pd.read_csv(tokens_file, sep=',', index_col='id', usecols=['id', 'value'], squeeze=True)
        )

    def _load_paths(self, paths_file: str) -> np.ndarray:
        paths = pd.read_csv(paths_file, sep=',', index_col='id', usecols=['id', 'nodeTypes'], squeeze=True)
        paths = paths.map(
            lambda nt: Path(
                list(map(int, nt.split()))
            )
        )
        return self._series_to_ndarray(paths)

    def _load_node_types(self, node_types_file: str) -> np.ndarray:
        node_types = pd.read_csv(node_types_file, sep=',', index_col='id', usecols=['id', 'type', 'direction'])
        node_types['nodeType'] = node_types.map(
            lambda row: NodeType(row['type'], row['direction'])
        )
        return self._series_to_ndarray(node_types['nodeType'])

    @staticmethod
    def _load_path_contexts_files(path_contexts_files: List[str], change_entities: pd.Series) \
            -> Tuple[np.ndarray, PathContexts]:

        starts, paths, ends = [], [], []
        labels = []
        for path_contexts_file in path_contexts_files:
            contexts = pd.read_csv(path_contexts_file, sep=',',
                                   usecols=['changeId', 'pathsCountBefore', 'pathsCountAfter', 'pathsAfter'])
            # Work only with method creations
            contexts = contexts[np.logical_and(contexts['pathsCountBefore'] == 0, contexts['pathsCountAfter'] > 0)]
            path_contexts = contexts['pathsAfter'].fillna('').map(
                lambda ctx: np.array(list(map(PathContext.fromstring, ctx.split(';'))), dtype=np.object)
                if ctx
                else np.array([])
            )
            starts.append(path_contexts.map(
                lambda ctx_array: np.fromiter(map(lambda ctx: ctx.start_token, ctx_array), np.int32,
                                              count=ctx_array.size)
            ).values)

            paths.append(path_contexts.map(
                lambda ctx_array: np.fromiter(map(lambda ctx: ctx.path, ctx_array), np.int32, count=ctx_array.size)
            ).values)

            ends.append(path_contexts.map(
                lambda ctx_array: np.fromiter(map(lambda ctx: ctx.end_token, ctx_array), np.int32, count=ctx_array.size)
            ).values)

            labels.append(contexts['changeId'].map(
                lambda change_id: change_entities.loc[change_id]
            ).values)

        starts = np.concatenate(starts)
        paths = np.concatenate(paths)
        ends = np.concatenate(ends)
        labels = np.concatenate(labels)
        print('labels', labels)
        print('starts, ends', starts, ends)
        return labels, PathContexts(starts, paths, ends)

    @staticmethod
    def _series_to_ndarray(series: pd.Series) -> np.ndarray:
        converted_values = np.empty(max(series.index) + 1, dtype=np.object)
        for ind, val in zip(series.index, series.values):
            converted_values[ind] = val
        return converted_values

    def tokens(self) -> np.ndarray:
        return self._tokens

    def paths(self) -> np.ndarray:
        return self._paths

    def node_types(self) -> np.ndarray:
        return self._node_types

    def labels(self) -> Union[np.ndarray, List[np.ndarray]]:
        return self._labels

    def path_contexts(self) -> Union[PathContexts, List[PathContexts]]:
        return self._path_contexts

    def n_classes(self) -> np.int32:
        return self._n_classes
